◯provideメソッド

  重複を取り除くテクニックの１つとして、ビューでERBと呼ばれている「埋め込みRuby」(Embedded Ruby) が使えます

  provideメソッドでパラメータを引き渡し

home.html.erb
<% provide(:title, "Home") %>
yieldメソッドで受け取る

application.html.erb
<title><%= yield(:title) %></title>
<!-- <title>Home</title> -->

provideメソッドで定義したものはlayoutファイル内においてyieldメソッドで呼び出すことができます。
---------------------------------------------------------

◯update_attributesメソッド
属性のハッシュを受け取り、成功時にはDBの更新と保存を続けて同時に行います (保存に成功した場合はtrueを返します)。ただし、検証に1つでも失敗すると、 update_attributesの呼び出しは失敗します。特定の属性のみを更新したい場合は、次のようにupdate_attributeを使います。このupdate_attributeには、検証を回避するといった効果もあります。

>> user.update_attribute(:name, "El Duderino")
=> true

----------------------------------------------------------

◯Strong Parameters (permitメソッド・requireメソッド)

Strong Parametersとはマスアサイメント脆弱性を回避するためにrails4以降に提供されるようになった機能

（マスアサインメントとは、フォームから送られてきたパラメーターをひとつにまとめて、一度に保存できるRailsの機能）

保存するときはこのパラメーターをストロングパラメーターにする必要があります。
そのときに使うメソッドがpermitメソッドです
permitメソッドによって保存するパラメーターの許可処理を行ったパラメーターのことをストロングパラメーターといいます。

requireメソッドはパラメータの中にモデルに対応するキーが存在するかを確認し、存在する場合にそのバリューを返します。
params.require(:user)
このメソッドを使わなくても
params[:user]
キーを指定しバリューを取得できる
 
 ↑このままだと取得はできでも保存はできないのでpermitメソッドを使う。
params.require(:user).permit(:name, :age, :tall, :weight)
consoleで確認した時に返ってくるパラメーターは全く同じですが、最後のpermittedがtrueに変わっているのが確認できます。
この部分がtrueになってはじめてマスアサイメント機能が使え保存や上書きができるようになります。

意図しないキーがparamsに入っていてもpermitメソッドで保存を許可してないので保存される心配がなくなる

permit!メソッドを使うと全てのキーを許可することができます。


----------------------------------------------------------

◯privateメソッド
それぞれのメソッドに呼び出し制限を設定するメソッドの中の一つ


public →制限なし（デフォルトではこの設定になっている）。
private →クラスの外からは呼び出せない。同じインスタンス内でのみ、関数形式で呼び出せる。
protected	→クラスの外からは呼び出せない。同じインスタンス内で呼び出せる。また、他のインスタンスでも同じクラスやサブクラスであれば呼び出せる。

それぞれのメソッドをクラス内で書くと、それ以降のメソッドはすべて指定した呼び出し制限が設定されます。
 privateキーワード以降のコードを強調するために、インデントを1段深くするとわかりやすい。

----------------------------------------------------------

◯beforeフィルター
beforeフィルターは、before_actionメソッドを使って何らかの処理が実行される直前に特定のメソッドを実行する仕組みでコントローラの中で使う
  before_action :logged_in_user, only: [:edit, :update]

beforeフィルターはデフォルトでコントローラ内の全てのアクションに適用されてしまうので:onlyオプションを渡すことで、:edit,:updateアクションだけに適用されるように制限をかける

----------------------------------------------------------

◯unless文
Rubyにおいて条件式が偽となった場合にだけ処理を実行する

 条件分岐で使う if ~ とは逆の意味となり、書き方は２つ。
 if文の”elsif”に相当するようなものは、unlessにはありません。
①
 unless 条件式
    実行する処理
end 

②
実行する処理  unless 条件式


----------------------------------------------------------

◯フレンドリーフォワーディング
ログインしていないユーザーがログインしていないと見れないページにアクセスしたい時、
ログインした後にアクセスしようとしていたページに親切に移動してくれること

----------------------------------------------------------
◯requestオブジェクト・responseオブジェクト

全てのコントラーラには、現在実行中のリクエストサイクルに関連するリクエストオブジェクトとレスポンスオブジェクトを指す、２つのアクセサメソッドがある。
requestメソッドはActionDispatch::Requestクラスのインスタンスを含み、responseメソッドは、今クライアントに戻されようとしている内容を表すレスポンスオブジェクトを返します。

----------------------------------------------------------

◯or演算子 ||

session[:forwarding_url] || default
上記は、値がnilでなければ左側を、そうでなければ右側を実行する
どちらかがというよりかは、右から検証されて、該当したらそれ以降は検証もされない。

----------------------------------------------------------

◯ridirect

URLを削除する動作はredirect文の後に置かれていても実行される
明示的にreturn分やメソッド内の最終行が呼び出されない限り、リダイレクトは発生しないのでredirect文の後にあるコードでも、そのコードは実行される。

 redirect_to user と redirect_to user_url(user) は同じ。省略できる


----------------------------------------------------------

◯debuggerメソッド

byebug gemによるdebuggerメソッドでこれを差し込むとrails s を立ち上げたターミナルにbyebugプロンプトが表示される
このプロンプトではrailsコンソールのようにコマンドを呼び出すことができ、アプリケーションのdebuggerが呼び出された瞬間の状態を確認することができます。
Ctrl-Dを押すと抜け出せる。
トラブルが起こっていそうなコードの近く(アクション内とか)にdebuggerを差し込んでシステムの状態を調べてみるといい。

----------------------------------------------------------

◯「!!」(バンバン (bang bang)演算子

この演算子を使うとそのオブジェクトを2回否定することになるので、
どんなオブジェクトも強制的に論理値に変換できます。

>> !!nil
=> fals

----------------------------------------------------------

◯form_for

ブラウザの検証を使ってみると、勝手にidやname,typeが作られている。

<%= f.label :name %>
<%= f.text_field :name %>
↓検証
<label for="user_name">Name</label>
<input id="user_name" name="user[name]" type="text" />

Railsはnameの値を使って、初期化したハッシュを (params変数経由で) 構成します。このハッシュは、入力された値に基づいてユーザーを作成するときに使われます

<form class="new_user" id="new_user" action="/users" accept-charset="UTF-8" method="post">

Railsはformタグを作成するときに@userオブジェクトを使います。すべてのRubyオブジェクトは自分のクラスを知っているので、Railsは@userのクラスがUserであることを認識します。また、@userは新しいユーザーなので、 Railsはpostメソッドを使ってフォームを構築すべきだと判断します。なお、新しいオブジェクトを作成するために必要なHTTPリクエストはPOSTなので、このメソッドはRESTfulアーキテクチャとして正しいリクエストになります

action="/users"とmethod="post"

この2つの属性では、/users に対してHTTPのPOSTリクエスト送信する、といった指示をしています (POSTリクエストを/usersというURLに送信)

formタグは、入力・送信フォームを作成するために使用される。 本文中では、入力・送信が必要ないので使用していない。



----------------------------------------------------------

◯パーシャル

出力を扱いやすく分割する仕組み。ファイル名の前に「＿」をつける。

----------------------------------------------------------

◯any?メソッド

any?メソッドはempty?メソッドと互いに補完します。

>> user.errors.empty?
=> false
>> user.errors.any?
=> true

any?メソッドはちょうどempty?と逆の動作で、要素が1つでもある場合はtrue、ない場合はfalseを返します。

Railsは、無効な内容の送信によって元のページに戻されると、CSSクラスfield_with_errorsを持ったdivタグでエラー箇所を自動的に囲んでくれます。

-------------------------------------------------------------

◯flash

flash[:success] = "Welcome to the Sample App!"
↓each文を用いると最終的には次のようなHTMLになります。
<div class="alert alert-success">Welcome to the Sample App!</div>
Bootstrap CSSは、このようなflashのクラス用に4つのスタイルを持っています (success、info、warning、danger)。

      <%
=begin      
        <div class="alert alert-<%= message_type%>"><%= message %></div>
        :message_typeに:successなどが入り、埋め込みRubyが自動的に文字列に変換して代入してくれる
        適用するCSSクラスをメッセージの種類によって変更するようにしている=>alert-success
=end      
      %>

--------------------------------------------------------------

◯SSL

Secure Sockets Layer (SSL)
これはローカルのサーバーからネットワークに流れる前に、大事な情報を暗号化する技術。
production.rbという本番環境の設定ファイルの1行を修正（configに「本番環境ではSSLを使うようにする」という設定をするということ）

次に、遠隔にあるサーバーのSSLをセットアップします。本番用のWebサイトでSSLを使えるようにするためには、ドメイン毎にSSL証明書を購入し、セットアップする必要があります。


--------------------------------------------------------------

◯option引数

def gravatar_for(user, options = {size: 80})
    size = options[:size]
end

引数にオプション引数を使い、処理で:sizeを持ってくることで変化に対応できる


--------------------------------------------------------------

◯Faker gem

gem 'faker', '1.7.3
実際にいそうなユーザー名を作成するgem

サンプルユーザーを生成するRubyスクリプト(Railsタスク)の追加はdb/seeds.rbファイルを使う

--------------------------------------------------------------

◯ページネーション(pagienation)
1つのページに一度に30人だけユーザーを表示するもの
最もシンプルなのはwill_paginate メソッド

これを使うためには、Gemfileにwill_paginate gem とbootstrap-will_paginate gemを両方含め、Bootstrapのページネーションスタイルを使ってwill_paginateを構成する必要があります

gem 'will_paginate',           '3.1.6'
gem 'bootstrap-will_paginate', '1.0.0'

ページネーションが動作するには、ユーザーのページネーションを行うようにRailsに指示するコードをindexビューに追加する
<%= will_paginate %>

paginateでは、キーが:pageで値がページ番号のハッシュを引数に取ります。
indexアクションでUsersをページネートする

  def index
    @users = User.paginate(page: params[:page])
  end


--------------------------------------------------------------
◯カラムのデータ型
https://qiita.com/mzmz__02/items/f018b67243175e8f0891


--------------------------------------------------------------

◯toggleメソッド
boolean(真偽値)のカラムがある場合、ぞの属性を反転させて返す。
toggle(:admin)はsaveが必要だが、
toggle!(:admin)はその属性を反転し保存する
