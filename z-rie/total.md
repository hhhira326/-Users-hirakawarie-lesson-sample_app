◯provideメソッド

  重複を取り除くテクニックの１つとして、ビューでERBと呼ばれている「埋め込みRuby」(Embedded Ruby) が使えます

  provideメソッドでパラメータを引き渡し

home.html.erb
<% provide(:title, "Home") %>
yieldメソッドで受け取る

application.html.erb
<title><%= yield(:title) %></title>
<!-- <title>Home</title> -->

provideメソッドで定義したものはlayoutファイル内においてyieldメソッドで呼び出すことができます。
---------------------------------------------------------

◯update_attributesメソッド
属性のハッシュを受け取り、成功時にはDBの更新と保存を続けて同時に行います (保存に成功した場合はtrueを返します)。ただし、検証に1つでも失敗すると、 update_attributesの呼び出しは失敗します。特定の属性のみを更新したい場合は、次のようにupdate_attributeを使います。このupdate_attributeには、検証を回避するといった効果もあります。

>> user.update_attribute(:name, "El Duderino")
=> true

----------------------------------------------------------

◯Strong Parameters (permitメソッド・requireメソッド)

Strong Parametersとはマスアサイメント脆弱性を回避するためにrails4以降に提供されるようになった機能

（マスアサインメントとは、フォームから送られてきたパラメーターをひとつにまとめて、一度に保存できるRailsの機能）

保存するときはこのパラメーターをストロングパラメーターにする必要があります。
そのときに使うメソッドがpermitメソッドです
permitメソッドによって保存するパラメーターの許可処理を行ったパラメーターのことをストロングパラメーターといいます。

requireメソッドはパラメータの中にモデルに対応するキーが存在するかを確認し、存在する場合にそのバリューを返します。
params.require(:user)
このメソッドを使わなくても
params[:user]
キーを指定しバリューを取得できる
 
 ↑このままだと取得はできでも保存はできないのでpermitメソッドを使う。
params.require(:user).permit(:name, :age, :tall, :weight)
consoleで確認した時に返ってくるパラメーターは全く同じですが、最後のpermittedがtrueに変わっているのが確認できます。
この部分がtrueになってはじめてマスアサイメント機能が使え保存や上書きができるようになります。

意図しないキーがparamsに入っていてもpermitメソッドで保存を許可してないので保存される心配がなくなる

permit!メソッドを使うと全てのキーを許可することができます。


----------------------------------------------------------

◯privateメソッド
それぞれのメソッドに呼び出し制限を設定するメソッドの中の一つ


public →制限なし（デフォルトではこの設定になっている）。
private →クラスの外からは呼び出せない。同じインスタンス内でのみ、関数形式で呼び出せる。
protected	→クラスの外からは呼び出せない。同じインスタンス内で呼び出せる。また、他のインスタンスでも同じクラスやサブクラスであれば呼び出せる。

それぞれのメソッドをクラス内で書くと、それ以降のメソッドはすべて指定した呼び出し制限が設定されます。
 privateキーワード以降のコードを強調するために、インデントを1段深くするとわかりやすい。

----------------------------------------------------------

◯beforeフィルター
beforeフィルターは、before_actionメソッドを使って何らかの処理が実行される直前に特定のメソッドを実行する仕組みでコントローラの中で使う
  before_action :logged_in_user, only: [:edit, :update]

beforeフィルターはデフォルトでコントローラ内の全てのアクションに適用されてしまうので:onlyオプションを渡すことで、:edit,:updateアクションだけに適用されるように制限をかける

----------------------------------------------------------

◯unless文
Rubyにおいて条件式が偽となった場合にだけ処理を実行する

 条件分岐で使う if ~ とは逆の意味となり、書き方は２つ。
 if文の”elsif”に相当するようなものは、unlessにはありません。
①
 unless 条件式
    実行する処理
end 

②
実行する処理  unless 条件式


----------------------------------------------------------

◯フレンドリーフォワーディング
ログインしていないユーザーがログインしていないと見れないページにアクセスしたい時、
ログインした後にアクセスしようとしていたページに親切に移動してくれること

----------------------------------------------------------
◯requestオブジェクト・responseオブジェクト

全てのコントラーラには、現在実行中のリクエストサイクルに関連するリクエストオブジェクトとレスポンスオブジェクトを指す、２つのアクセサメソッドがある。
requestメソッドはActionDispatch::Requestクラスのインスタンスを含み、responseメソッドは、今クライアントに戻されようとしている内容を表すレスポンスオブジェクトを返します。

----------------------------------------------------------

◯or演算子 ||

session[:forwarding_url] || default
上記は、値がnilでなければ左側を、そうでなければ右側を実行する
どちらかがというよりかは、右から検証されて、該当したらそれ以降は検証もされない。

----------------------------------------------------------

◯ridirect

URLを削除する動作はredirect文の後に置かれていても実行される
明示的にreturn分やメソッド内の最終行が呼び出されない限り、リダイレクトは発生しないのでredirect文の後にあるコードでも、そのコードは実行される。

 redirect_to user と redirect_to user_url(user) は同じ。省略できる


----------------------------------------------------------

◯debuggerメソッド

byebug gemによるdebuggerメソッドでこれを差し込むとrails s を立ち上げたターミナルにbyebugプロンプトが表示される
このプロンプトではrailsコンソールのようにコマンドを呼び出すことができ、アプリケーションのdebuggerが呼び出された瞬間の状態を確認することができます。
Ctrl-Dを押すと抜け出せる。
トラブルが起こっていそうなコードの近く(アクション内とか)にdebuggerを差し込んでシステムの状態を調べてみるといい。

----------------------------------------------------------

◯「!!」(バンバン (bang bang)演算子

この演算子を使うとそのオブジェクトを2回否定することになるので、
どんなオブジェクトも強制的に論理値に変換できます。

>> !!nil
=> fals

----------------------------------------------------------

◯form_for

ブラウザの検証を使ってみると、勝手にidやname,typeが作られている。

<%= f.label :name %>
<%= f.text_field :name %>
↓検証
<label for="user_name">Name</label>
<input id="user_name" name="user[name]" type="text" />

Railsはnameの値を使って、初期化したハッシュを (params変数経由で) 構成します。このハッシュは、入力された値に基づいてユーザーを作成するときに使われます

<form class="new_user" id="new_user" action="/users" accept-charset="UTF-8" method="post">

Railsはformタグを作成するときに@userオブジェクトを使います。すべてのRubyオブジェクトは自分のクラスを知っているので、Railsは@userのクラスがUserであることを認識します。また、@userは新しいユーザーなので、 Railsはpostメソッドを使ってフォームを構築すべきだと判断します。なお、新しいオブジェクトを作成するために必要なHTTPリクエストはPOSTなので、このメソッドはRESTfulアーキテクチャとして正しいリクエストになります

action="/users"とmethod="post"

この2つの属性では、/users に対してHTTPのPOSTリクエスト送信する、といった指示をしています (POSTリクエストを/usersというURLに送信)

formタグは、入力・送信フォームを作成するために使用される。 本文中では、入力・送信が必要ないので使用していない。



----------------------------------------------------------

◯パーシャル

出力を扱いやすく分割する仕組み。ファイル名の前に「＿」をつける。

----------------------------------------------------------

◯any?メソッド

any?メソッドはempty?メソッドと互いに補完します。

>> user.errors.empty?
=> false
>> user.errors.any?
=> true

any?メソッドはちょうどempty?と逆の動作で、要素が1つでもある場合はtrue、ない場合はfalseを返します。

Railsは、無効な内容の送信によって元のページに戻されると、CSSクラスfield_with_errorsを持ったdivタグでエラー箇所を自動的に囲んでくれます。

-------------------------------------------------------------

◯flash

flash[:success] = "Welcome to the Sample App!"
↓each文を用いると最終的には次のようなHTMLになります。
<div class="alert alert-success">Welcome to the Sample App!</div>
Bootstrap CSSは、このようなflashのクラス用に4つのスタイルを持っています (success、info、warning、danger)。

      <%
=begin      
        <div class="alert alert-<%= message_type%>"><%= message %></div>
        :message_typeに:successなどが入り、埋め込みRubyが自動的に文字列に変換して代入してくれる
        適用するCSSクラスをメッセージの種類によって変更するようにしている=>alert-success
=end      
      %>

--------------------------------------------------------------

◯SSL

Secure Sockets Layer (SSL)
これはローカルのサーバーからネットワークに流れる前に、大事な情報を暗号化する技術。
production.rbという本番環境の設定ファイルの1行を修正（configに「本番環境ではSSLを使うようにする」という設定をするということ）

次に、遠隔にあるサーバーのSSLをセットアップします。本番用のWebサイトでSSLを使えるようにするためには、ドメイン毎にSSL証明書を購入し、セットアップする必要があります。


--------------------------------------------------------------

◯option引数

def gravatar_for(user, options = {size: 80})
    size = options[:size]
end

引数にオプション引数を使い、処理で:sizeを持ってくることで変化に対応できる


--------------------------------------------------------------

◯Faker gem

gem 'faker', '1.7.3
実際にいそうなユーザー名を作成するgem

サンプルユーザーを生成するRubyスクリプト(Railsタスク)の追加はdb/seeds.rbファイルを使う
rails db:seedコマンドは、db/seeds.rbにあるサンプルデータをデータベースに流し込む

--------------------------------------------------------------

◯ページネーション(pagienation)
1つのページに一度に30人だけユーザーを表示するもの
最もシンプルなのはwill_paginate メソッド

これを使うためには、Gemfileにwill_paginate gem とbootstrap-will_paginate gemを両方含め、Bootstrapのページネーションスタイルを使ってwill_paginateを構成する必要があります

gem 'will_paginate',           '3.1.6'
gem 'bootstrap-will_paginate', '1.0.0'

ページネーションが動作するには、ユーザーのページネーションを行うようにRailsに指示するコードをindexビューに追加する
<%= will_paginate %>

paginateでは、キーが:pageで値がページ番号のハッシュを引数に取ります。
indexアクションでUsersをページネートする

  def index
    @users = User.paginate(page: params[:page])
  end


--------------------------------------------------------------
◯カラムのデータ型
https://qiita.com/mzmz__02/items/f018b67243175e8f0891


--------------------------------------------------------------

◯toggleメソッド
boolean(真偽値)のカラムがある場合、ぞの属性を反転させて返す。
toggle(:admin)はsaveが必要だが、
toggle!(:admin)はその属性を反転し保存する

--------------------------------------------------------------
◯references型

$ rails generate model Micropost content:text user:references
references型を利用すると、自動的にインデックスと外部キー参照付きのuser_idカラムが追加され、UserとMicropostを関付けする下準備をしてくれる。

「app/models/micropost.rb」
   belongs_to :user

--------------------------------------------------------------
◯buildメソッド
newメソッドと同じく、モデルオブジェクトを生成するメソッド
機能的な違いはないが、モデルを関連付けしている場合はbuildを利用するがデータベースには反映されない。

--------------------------------------------------------------
◯belongs_to / has_many

モデル間の関連付け
belongs_to → 1対1
has_many → 1対多

----------------------------------------------------------
◯pluralizeメソッド
英語専用のテキストヘルパー
pluralizeの最初の引数に整数が与えられると、それに基づいて2番目の引数の英単語を複数形に変更したものを返します。このメソッドの背後には強力なインフレクター (活用形生成) があり、不規則活用を含むさまざまな単語を複数形にすることができます

-------------------------------------------------------------
◯whereメソッド

https://pikawaka.com/rails/where

デーブル内の条件に一致したレコードを配列の形で取得することができるメソッド
特定のレコードだけ取得したり、検索機能を実装したりする時に使うメソッド

ex)
モデル名.where("条件")
@users = User.where(age: 20)
=>ageカラムに20が入っているレコードを全て取得

①シンボル指定
User.where(name: "hoge")
※１つの条件で検索する時にはこっち（SQLインジェクションを防げる）

②文字列指定
User.where("name = hoge")

◆プレースホルダ
SQLインジェクションを防ぐ書き方

 User.where("name = ?", "hoge")
 「?」はプレースホルダーと呼ばれ、第二引数で指定した値が置き換えられる
 User.where ("name = ? and age = ?", "hoge ",20)

 SQL文に変数を代入する場合は常にエスケープする習慣をつける

◆not検索

①User.whre.not(name: "hoge")
②User.whre.("NOT(name= 'hoge')")

◆複数条件(in句)

①User.where(id: [1,2])
②User.where("id IN (1,2)")

◆あいまい検索 (LIKE句)

検索機能を実装したい時などに使う

User.where("name LIKE?", "%あ%")
検索したい文字列には%と_を文字列と組み合わせた値として記述する

「%」空白文字を含む任意の複数文字列
%あ% → 「あ」がつく文字列
あ% → 「あ」で始まる文字列
%あ → 「あ」で終わる文字列

「_」任意の１文字
あ_ → 「あ」から始まる２文字の単語 ex) あめ、あお
_あ → 「あ」で終わる２文字の単語 ex) コア、ギア


-------------------------------------------------------------
◯request.referrerメソッド

レンドリーフォワーディングのrequest.url変数 と似ていて、一つ前のURLを返します 

 redirect_to request.referrer || root_url

マイクロポストがHomeページから削除された場合でもプロフィールページから削除された場合でも、request.referrerを使うことでDELETEリクエストが発行されたページに戻すことができるので、非常に便利です。ちなみに、元に戻すURLが見つからなかった場合でも (例えばテストではnilが返ってくることもあります)、リスト 13.52の||演算子でroot_urlをデフォルトに設定しているため、大丈夫です。

redirect_back(fallback_location: root_url)と置き換えてもうまく動く（rails5から導入）

-------------------------------------------------------------
◯画像のアップロード

gem 'carrierwave',             '1.2.2'
gem 'mini_magick',             '4.7.0'

(Rails 5.2から標準となったのはActive Storage)

CarrierWaveに画像と関連付けたモデルを伝えるためには、mount_uploaderというメソッドを使います。このメソッドは、引数に属性名のシンボルと生成されたアップローダーのクラス名を取ります。

[micropost.rb]
mount_uploader :picture, PictureUploader

--------------------------------------------------------------
◯インデックス
特定のカラムからデータを取得する際に、テーブルの中の特定のカラムのデータを複製し検索が行いやすいようにしたもの
・メリット：データの読み込み・取得が早くなる。
・デメリット：書き込みの速度が倍かかる。
基本的にindexは、

ある程度多くのデータを格納するテーブルの、格納される値がそれぞれ異なるようなカラムの中で、検索がよく行われるカラム
に対して張ると効果的

◯add_index
インデックスを追加する
add_index テーブル名, [:カラム名1, :カラム名2, ・・・]

オプション
:name - インデックスの名前
:unique - trueを指定するとユニークなインデックス
:length - インデックスに含まれるカラムの長さ

--------------------------------------------------------------
◯include?メソッド
引数で指定した要素が配列中に含まれているか判定するメソッド
num = [1,2,3]
num.include?(2)
=>true

--------------------------------------------------------------
◯forein key
外部キーのこと

--------------------------------------------------------------
◯hidden_field_tagメソッド
モデルと関係のない隠しフィールドの生成

<%= hidden_field_tag :followed_id, @user.id %>
以下のフォーム用HTMLを生成する
<input id="followed_id" name="followed_id" type="hidden" value="3" />
隠しフィールドのinputタグを使うことで、ブラウザ上に表示させずに適切な情報を含めることができる


----------------------------------------------------------
◯Ajax
ajaxを使うことでwebページからサーバーに非同期で、ページを移動することなくリクエストを送信することができる
フォローボタンを押してリダイレクトせずにできる。
form_for
↓
form_for ...., remote: true
とするだけで、railsは自動的にAjaxを使うようになる


◯respond_toメソッド
Ajaxリクエストに応答できるようにする（リクエストの種類によって応答を場合分けする）

respond_to do |format|
  format.html {redirect_to user}
  format.js
end

上から順に処理を実行するのではなく、いずれかの一行が実行される
if文を使った分岐処理に近いイメージ。

ブラウザ側でJSが無効になっていた場合（Ajaxリクエストが送れない場合）でもうまく動くように設定↓
「config/application.rb」
    config.action_view.embed_authenticity_token_in_remote_forms = true

